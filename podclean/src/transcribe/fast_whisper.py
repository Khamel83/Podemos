import subprocess
import tempfile
import os
import json
import re

def parse_srt_to_segments(srt_path):
    segments = []
    with open(srt_path, 'r', encoding='utf-8') as f:
        content = f.read()

    # Regex to find SRT blocks
    # Group 1: segment number (ignored)
    # Group 2: start time (HH:MM:SS,ms)
    # Group 3: end time (HH:MM:SS,ms)
    # Group 4: text content
    srt_pattern = re.compile(r'\d+\n(\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})\n([\s\S]*?)(?:\n\n|\Z)')

    def srt_time_to_seconds(srt_time):
        hours, minutes, seconds_ms = srt_time.split(':')
        seconds, milliseconds = seconds_ms.split(',')
        return int(hours) * 3600 + int(minutes) * 60 + int(seconds) + int(milliseconds) / 1000.0

    for match in srt_pattern.finditer(content):
        start_time_str, end_time_str, text = match.groups()
        start_seconds = srt_time_to_seconds(start_time_str)
        end_seconds = srt_time_to_seconds(end_time_str)
        segments.append({
            "start": start_seconds,
            "end": end_seconds,
            "text": text.strip()
        })
    return segments

def fast_transcribe(audio_path, model_size="small.en", **_):
    model_map = {
        "tiny":"ggml-tiny.bin", "base":"ggml-base.bin",
        "small.en":"ggml-small.en.bin", "small":"ggml-small.en.bin" # Use small.en for small model
    }
    model_file = f"whisper.cpp/models/{model_map.get(model_size,'ggml-small.en.bin')}"
    out_prefix = tempfile.mktemp(prefix="wsp_")
    
    # Ensure the whisper.cpp executable path is correct
    whisper_cpp_executable = "./whisper.cpp/build/bin/whisper-cli"
    if not os.path.exists(whisper_cpp_executable):
        # Fallback if whisper-cli is not found, try main (deprecated but might exist)
        whisper_cpp_executable = "./whisper.cpp/build/bin/main"
        if not os.path.exists(whisper_cpp_executable):
            raise FileNotFoundError(f"whisper.cpp executable not found at {whisper_cpp_executable}. Please ensure it's built.")

    cmd = [
        whisper_cpp_executable, "-m", model_file,
        "-f", audio_path, "-osrt", "-of", out_prefix,
        # add light VAD to reduce junk segments:
        # "-vtt"  # optional: also write VTT if you prefer
    ]
    
    print(f"Running whisper.cpp command: {' '.join(cmd)}")
    subprocess.run(cmd, check=True)
    srt_path = f"{out_prefix}.srt"
    
    if not os.path.exists(srt_path):
        raise FileNotFoundError(f"SRT file not generated by whisper.cpp at {srt_path}")

    return parse_srt_to_segments(srt_path)

if __name__ == "__main__":
    # Example usage (requires a dummy audio file and whisper.cpp built)
    # Create a dummy audio file for testing:
    # ffmpeg -f lavfi -i "sine=frequency=1000:duration=10" test_audio.mp3
    test_audio_path = "test_audio.mp3" # Create this file for testing
    if os.path.exists(test_audio_path):
        print(f"Transcribing {test_audio_path}...")
        results = fast_transcribe(test_audio_path, model_size="tiny.en") # Use tiny.en for quick test
        for segment in results:
            print(f"[{segment['start']:.2f}s -> {segment['end']:.2f}s] {segment['text']}")
    else:
        print(f"Please create a dummy audio file named '{test_audio_path}' in the current directory for testing.")
        print("You can create one using: ffmpeg -f lavfi -i \"sine=frequency=1000:duration=10\" test_audio.mp3")
    
    # Test SRT parsing
    dummy_srt_content = """1
00:00:00,000 --> 00:00:05,500
Hello, and welcome to the podcast.

2
00:00:06,000 --> 00:00:10,200
This is a test segment.

3
00:00:11,000 --> 00:00:15,000
Thank you for listening.
"""
    with open("dummy.srt", "w") as f:
        f.write(dummy_srt_content)
    parsed_segments = parse_srt_to_segments("dummy.srt")
    print("\nParsed SRT segments:")
    for segment in parsed_segments:
        print(segment)
    os.remove("dummy.srt") # Clean up dummy file

